<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Handling Interrupts</title>
<link href="../static/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="../static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../static/page.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav>
<a href="../">Home</a>
      ·
      <span class="dropdown">
<a href="#">Lessons</a>
<span class="dropdown-content" id="nav-lessons">
<a href="../intro/">Introduction</a>
<a href="../des/">Discrete Event Simulation</a>
<a href="../metrics/">Simple Metrics</a>
<a href="../scenarios/">Exploring Scenarios</a>
<a href="../interrupts/">Handling Interrupts</a>
<a href="../insight/">Insights</a>
<a href="../finale/">Conclusion</a>
</span>
</span>
      ·
      <span class="dropdown">
<a href="#">Appendices</a>
<span class="dropdown-content" id="nav-appendices">
<a href="../license/">License</a>
<a href="../conduct/">Code of Conduct</a>
<a href="../contributing/">Contributing</a>
<a href="../bibliography/">Bibliography</a>
<a href="../glossary/">Glossary</a>
</span>
</span>
</nav>
<main>
<h1>Handling Interrupts</h1>
<p id="terms">Terms defined: <a class="term-defined" href="../glossary/#lifecycle-method">lifecycle method</a>, <a class="term-defined" href="../glossary/#state-machine">state machine</a></p>
<h2>Throwing Work Away</h2>
<ul>
<li>Jobs don't have priorities</li>
<li>The manager interrupts</li>
<li>Any work done on the current job is lost<ul>
<li>We'll fix this later</li>
</ul>
</li>
<li>Parameters and simulation class</li>
</ul>
<div class="python codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Params</span><span class="p">:</span>
    <span class="c1"># …as before…</span>
    <span class="n">t_interrupt_interval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">(</span><span class="n">Environment</span><span class="p">):</span>
    <span class="c1"># …as before…</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rand_interrupt_arrival</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">expovariate</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">t_interrupt_interval</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>But we need a way to get at the coder's process (i.e., the generator) in order to interrupt it<ul>
<li>The <code>Coder</code> instance is something we've built around the generator</li>
<li><code>Environment.process(…)</code> returns the generator, so we can store that</li>
</ul>
</li>
</ul>
<div class="python codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">(</span><span class="n">Environment</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># …queue, manager, and monitor as before…</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">Interrupter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coders</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">n_coder</span><span class="p">):</span>
            <span class="n">coder</span> <span class="o">=</span> <span class="n">Coder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">coder</span><span class="o">.</span><span class="n">proc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">coder</span><span class="o">.</span><span class="n">run</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coder</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">t_sim</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>Our new <code>Interrupter</code> reaches inside a coder to get its process</li>
</ul>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Interrupter</span><span class="p">(</span><span class="n">Recorder</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">rand_interrupt_arrival</span><span class="p">())</span>
            <span class="n">coder</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">coders</span><span class="p">)</span>
            <span class="n">coder</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">interrupt</span><span class="p">()</span>
</code></pre></div>
<div class="callout">
<ul>
<li>When we call <code>proc.interrupt()</code>, SimPy raises an <code>Interrupt</code> exception inside the generator</li>
<li>But it can only do this while the framework is running, <em>not</em> while the process is running<ul>
<li>Because only one thing runs at a time</li>
</ul>
</li>
<li>So the exception is only raised when the process interacts with the environment<ul>
<li>I.e., at <code>queue.get()</code>, <code>timeout()</code>, or other <code>yield</code> points</li>
</ul>
</li>
</ul>
</div>
<ul>
<li>Write a <code>Coder</code> that throws away whatever job it's doing when it is interrupted<ul>
<li>Not realistic, but it gives us a chance to learn about interrupts</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre class=""><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">simpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">Interrupt</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Coder</span><span class="p">(</span><span class="n">Recorder</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">job</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="n">job</span><span class="o">.</span><span class="n">t_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>
                <span class="n">job</span><span class="o">.</span><span class="n">t_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">t_work</span> <span class="o">+=</span> <span class="n">job</span><span class="o">.</span><span class="n">t_end</span> <span class="o">-</span> <span class="n">job</span><span class="o">.</span><span class="n">t_start</span>
            <span class="k">except</span> <span class="n">Interrupt</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_interrupt</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">job</span><span class="o">.</span><span class="n">t_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
                <span class="n">job</span><span class="o">.</span><span class="n">discarded</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">t_work</span> <span class="o">+=</span> <span class="n">job</span><span class="o">.</span><span class="n">t_end</span> <span class="o">-</span> <span class="n">job</span><span class="o">.</span><span class="n">t_start</span>
</code></pre></div>
<ul>
<li>Exercise: how does the percentage of discarded jobs change as the interrupt rate changes?</li>
</ul>
<h2>Resuming Work</h2>
<ul>
<li>General idea: coders have a stack of work<ul>
<li>At most one regular job</li>
<li>And zero or more interrupts stacked on top of it</li>
<li>When an interrupt arrives, it goes on the top of the stack</li>
</ul>
</li>
<li>Do the simple bits first<ul>
<li>Subclass <code>Job</code> so that we can call different methods for defining duration</li>
</ul>
</li>
<li>Notice that we're piling up a bunch of parameters whose values we probably don't know</li>
</ul>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Params</span><span class="p">:</span>
    <span class="c1"># …as before…</span>
    <span class="n">t_interrupt_interval</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span>
    <span class="n">t_interrupt_mean</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">t_interrupt_std</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span>

<span class="k">class</span><span class="w"> </span><span class="nc">JobRegular</span><span class="p">(</span><span class="n">Job</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">rand_job_duration</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">JobInterrupt</span><span class="p">(</span><span class="n">Job</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">rand_interrupt_duration</span><span class="p">()</span>
</code></pre></div>
<ul>
<li><code>Manager</code> creates <code>JobRegular</code>, <code>Interrupter</code> creates <code>JobInterrupt</code></li>
<li>Note that <code>Interrupter</code> passes the new job to <code>.interrupt()</code> so that it becomes the exception's <code>.cause</code></li>
</ul>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Interrupter</span><span class="p">(</span><span class="n">Recorder</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">rand_interrupt_arrival</span><span class="p">())</span>
            <span class="n">coder</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">coders</span><span class="p">)</span>
            <span class="n">coder</span><span class="o">.</span><span class="n">proc</span><span class="o">.</span><span class="n">interrupt</span><span class="p">(</span><span class="n">JobInterrupt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="p">))</span>
</code></pre></div>
<ul>
<li>It took several tries to get the <code>Coder</code> right</li>
<li>The problem is that interrupts can occur whenever the coder interacts with SimPy<ul>
<li>So if the coder does anything with SimPy in the <code>except</code> block,
    we can have an interrupt while we're handling an interrupt</li>
</ul>
</li>
<li>Solution is to implement a <a href="../glossary/#state-machine">state machine</a><ol>
<li>No work, so get a new job from the coding queue.</li>
<li>Job on top of the stack is incomplete, so do some work.</li>
<li>Job on top of the stack is complete, so pop it.</li>
</ol>
</li>
<li>If an interrupt occurs:<ul>
<li>Add some time to the current job <em>if we actually started it</em></li>
<li>Push the new job on the stack</li>
<li>Note: the new job arrives as the <code>Interrupt</code> exception's cause</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Coder</span><span class="p">(</span><span class="n">Recorder</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">started</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># No work in hand, so get a new job.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">job</span> <span class="o">=</span> <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">code_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                    <span class="n">job</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
                <span class="c1"># Current job is incomplete, so try to finish it.</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">done</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">duration</span><span class="p">:</span>
                    <span class="n">job</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">started</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">duration</span> <span class="o">-</span> <span class="n">job</span><span class="o">.</span><span class="n">done</span><span class="p">)</span>
                    <span class="n">job</span><span class="o">.</span><span class="n">done</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">duration</span>
                <span class="c1"># Current job is complete.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">job</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">job</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">Interrupt</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="c1"># Some work has been done on the current job, so save it.</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">started</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">now</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
                    <span class="n">job</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">job</span><span class="o">.</span><span class="n">interrupt</span><span class="p">()</span>
                    <span class="n">job</span><span class="o">.</span><span class="n">done</span> <span class="o">+=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">started</span>
                <span class="c1"># Put the interrupting job on the stack.</span>
                <span class="n">job</span> <span class="o">=</span> <span class="n">exc</span><span class="o">.</span><span class="n">cause</span>
                <span class="n">job</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
</code></pre></div>
<ul>
<li>This works, but the code is hard to understand, debug, and extend</li>
</ul>
<h2>Decomposing Jobs</h2>
<ul>
<li>Design has two parts:<ul>
<li>Treat interrupts as high-priority jobs</li>
<li>Break regular jobs into short fragments so that interrupts are handled promptly (but not immediately)</li>
</ul>
</li>
<li>Define three priorities:<ul>
<li>High: interrupt</li>
<li>Medium: fragments of regular job</li>
<li>Low: regular jobs</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Priority</span><span class="p">:</span>
    <span class="n">HIGH</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">MEDIUM</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">LOW</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<ul>
<li>Generic <code>Job</code> has a few <a href="../glossary/#lifecycle-method">lifecycle methods</a> for child classes to override<ul>
<li><code>Job.start</code> is called when work starts on a job</li>
<li><code>Job.complete</code> is called when the job is completed</li>
<li><code>Job.is_complete</code> tells us whether the job has been completed or not</li>
<li><code>Job.needs_decomp</code> tells us whether the job needs to be decomposed</li>
</ul>
</li>
<li>We will explain <code>sim.do_nothing()</code> shortly</li>
</ul>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Job</span><span class="p">(</span><span class="n">Recorder</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_create</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_complete</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_complete</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">now</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">do_nothing</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_complete</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">needs_decomp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">priority</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_create</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">t_create</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">priority</span>
</code></pre></div>
<ul>
<li><code>JobInterrupt</code> is the simplest child class</li>
</ul>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">JobInterrupt</span><span class="p">(</span><span class="n">Job</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">Priority</span><span class="o">.</span><span class="n">HIGH</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">rand_interrupt_duration</span><span class="p">()</span>
</code></pre></div>
<ul>
<li><code>JobRegular</code> overrides <code>.needs_decomp()</code><ul>
<li>If this job isn't complete <em>and</em> the time required is greater than the decomposition threshold</li>
<li>The latter parameter is another completely arbitrary number</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">JobRegular</span><span class="p">(</span><span class="n">Job</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">Priority</span><span class="o">.</span><span class="n">LOW</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">rand_job_duration</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">needs_decomp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complete</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">t_decomposition</span><span class="p">)</span>
</code></pre></div>
<ul>
<li><code>JobFragment</code> is the most complex<ul>
<li>Duration is specified by its creator (part of the total time required by a regular job)</li>
<li>And it has a reference to a placeholder that keeps track of undone fragments</li>
</ul>
</li>
<li>When then fragment is completed, it checks to see if it is the last one in its group<ul>
<li>If so, it bumps the priority of the completed job to medium and puts it back in the coder's queue</li>
<li>If not, it does nothing</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">JobFragment</span><span class="p">(</span><span class="n">Job</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coder</span><span class="p">,</span> <span class="n">placeholder</span><span class="p">,</span> <span class="n">duration</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">coder</span><span class="o">.</span><span class="n">sim</span><span class="p">,</span> <span class="n">Priority</span><span class="o">.</span><span class="n">MEDIUM</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coder</span> <span class="o">=</span> <span class="n">coder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">placeholder</span> <span class="o">=</span> <span class="n">placeholder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">placeholder</span><span class="o">.</span><span class="n">count</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">placeholder</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">placeholder</span><span class="o">.</span><span class="n">job</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">placeholder</span><span class="o">.</span><span class="n">job</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">Priority</span><span class="o">.</span><span class="n">MEDIUM</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coder</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">placeholder</span><span class="o">.</span><span class="n">job</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">do_nothing</span><span class="p">()</span>
</code></pre></div>
<ul>
<li>When <code>.complete</code> wants to put the original (regular) job back in the coder's queue,
    it would be natural to call <code>yield self.code.queue.put(…)</code></li>
<li>But what if it doesn't?</li>
<li>Solution:<ul>
<li><code>.complete</code> always returns something that can be yielded</li>
<li>Either "put this job in queue" <em>or</em> "wait for 0 ticks"</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre class=""><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Simulation</span><span class="p">(</span><span class="n">Environment</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">do_nothing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>
<ul>
<li><code>Coder.run</code> gets a job from the general "new work" queue or from its priority queue<ul>
<li>Gives preference to the latter so that interrupts and fragments are done before regular work</li>
<li>Always yields result of <code>job.complete()</code></li>
</ul>
</li>
</ul>
<div class="codehilite"><pre class=""><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">job</span> <span class="o">=</span> <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">job</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">job</span><span class="o">.</span><span class="n">needs_decomp</span><span class="p">():</span>
                <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">job</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">job</span><span class="o">.</span><span class="n">complete</span><span class="p">()</span>
</code></pre></div>
<ul>
<li>To decompose a job:<ul>
<li>Figure out the durations of the fragments</li>
<li>Create a placeholder to keep track of them and the original job</li>
<li>Put the fragments in the coder's priority queue</li>
</ul>
</li>
</ul>
<div class="codehilite"><pre class=""><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">job</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">t_decomposition</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">duration</span> <span class="o">/</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">duration</span> <span class="o">-</span> <span class="p">(</span><span class="n">num</span> <span class="o">*</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">durations</span> <span class="o">=</span> <span class="p">[</span><span class="n">extra</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="n">size</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">)]]</span>
        <span class="n">placeholder</span> <span class="o">=</span> <span class="n">Placeholder</span><span class="p">(</span><span class="n">job</span><span class="o">=</span><span class="n">job</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">durations</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">durations</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">JobFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">placeholder</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
</code></pre></div>
<ul>
<li>So is this better than using interrupts?<ul>
<li>250 lines for decomposition vs. 212 for interrupts</li>
<li>Decomposition approach was simpler to debug</li>
<li>But tracking sub-jobs is harder</li>
</ul>
</li>
</ul>
</main>
<footer>
<div class="row">
<div class="col-3 left">
	  ⇐ <a href="../scenarios/">Exploring Scenarios</a>
</div>
<div class="col-6 center">
<a href="../"></a>
	  © 2025
	  <a href="../#acknowledgments">the authors</a>
</div>
<div class="col-3 right">
<a href="../insight/">Insights</a> ⇒
	</div>
</div>
</footer>
</body>
</html>