<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Interruptions</title>
<link href="../static/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="../static/page.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav>
<a href="../">Home</a>
      ·
      <span class="dropdown">
<a href="#">Lessons</a>
<span class="dropdown-content" id="nav-lessons">
<a href="../intro/">Introduction</a>
<a href="../simple/">Simple Simulations</a>
<a href="../teams/">Teams</a>
<a href="../features/">More Features</a>
<a href="../interrupts/">Interruptions</a>
<a href="../finale/">Conclusion</a>
</span>
</span>
      ·
      <span class="dropdown">
<a href="#">Appendices</a>
<span class="dropdown-content" id="nav-appendices">
<a href="../generators/">Generators</a>
<a href="../license/">License</a>
<a href="../conduct/">Code of Conduct</a>
<a href="../contributing/">Contributing</a>
<a href="../bibliography/">Bibliography</a>
<a href="../glossary/">Glossary</a>
</span>
</span>
</nav>
<main>
<h1>Interruptions</h1>
<h2>Throwing Work Away</h2>
<ul>
<li>Jobs don't have priorities</li>
<li>The manager interrupts</li>
<li>Any work done on the current job is lost<ul>
<li>We'll fix this later</li>
</ul>
</li>
<li>Parameters</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="panic_and_discard.py">PARAMS = {
    "n_programmer": 1,
    "seed": 12345,
    "t_develop_mu": 0.5,
    "t_develop_sigma": 0.6,
    "t_interrupt_arrival": 5.0,  # new
    "t_job_arrival": 1.0,
    "t_monitor": 5,
    "t_sim": 20,
}
</code></pre>
<ul>
<li>Simulation<ul>
<li>Go back to a regular <code>Store</code> (first in, first out, no priority, no triage)</li>
<li>Keep a list of programmers' processes</li>
<li>Rename <code>manager</code> to <code>creator</code> and add <code>interruptor</code></li>
</ul>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="panic_and_discard.py">class Simulation:
    def __init__(self, params):
        self.params = params
        self.env = Environment()
        self.queue = Store(self.env)
        self.queue_length = []
        self.programmers = []

    def run(self):
        Job.clear()
        self.env.process(self.monitor())
        self.env.process(creator(self))
        self.env.process(interruptor(self))
        self.programmers = [
            self.env.process(programmer(self, i)) for i in range(self.params["n_programmer"])
        ]
        self.env.run(until=self.params["t_sim"])
</code></pre>
<ul>
<li><code>Job</code> keeps track of whether it was discarded or not</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="panic_and_discard.py">    def __init__(self, sim):
        …as before…
        self.discarded = False
</code></pre>
<ul>
<li><code>interruptor</code> waits a random interval, chooses a programmer at random, and interrupts her<ul>
<li>Need the generator object</li>
<li>Call its <code>interrupt</code> method to send a <code>simpy.Interrupt</code> exception into the generator</li>
</ul>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="panic_and_discard.py">def interruptor(sim):
    while True:
        yield sim.env.timeout(sim.rand_interrupt())
        programmer = random.choice(sim.programmers)
        programmer.interrupt()
</code></pre>
<ul>
<li><code>programmer</code> needs to handle these interruption exceptions<ul>
<li>Throw away current job and start again</li>
</ul>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="panic_and_discard.py">def programmer(sim, worker_id):
    while True:
        try:
            job = yield sim.queue.get()
            job.t_start = sim.env.now
            job.worker_id = worker_id
            yield sim.env.timeout(job.t_develop)
            job.t_end = sim.env.now
        except Interrupt:
            job.t_end = sim.env.now
            job.discarded = True
</code></pre>
<ul>
<li>Works fine until we add one line to clear the job each time around the loop</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="panic_and_discard_reset.py">def programmer(sim, worker_id):
    while True:
        job = None
        try:
            job = yield sim.queue.get()
            job.t_start = sim.env.now
            job.worker_id = worker_id
            yield sim.env.timeout(job.t_develop)
            job.t_end = sim.env.now
        except Interrupt:
            job.t_end = sim.env.now
            job.discarded = True
</code></pre>
<ul>
<li>Problem is that the interruption can occur inside <code>sim.queue.get()</code></li>
<li>Only update the job if we got one</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="panic_and_discard_corrected.py">def programmer(sim, worker_id):
    while True:
        job = None
        try:
            job = yield sim.queue.get()
            job.t_start = sim.env.now
            job.worker_id = worker_id
            yield sim.env.timeout(job.t_develop)
            job.t_end = sim.env.now
        except Interrupt:
            if job is not None:
                job.t_end = sim.env.now
                job.discarded = True
</code></pre>
<h2>Resuming Interrupted Work</h2>
<ul>
<li>Put current task aside when interrupted, then resume it<ul>
<li>No penalty for resumption (unrealistic, but we'll fix that later)</li>
</ul>
</li>
<li>For the moment, every interrupt is 5 ticks long</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="interrupt_resume.py">PARAMS = {
    …as before…
    "t_interrupt_arrival": 5.0,
    "t_interrupt_len": 5.0,
}
</code></pre>
<ul>
<li>Happy path<ul>
<li>If there's a pending job, resume it</li>
<li>Otherwise, get a new job</li>
<li>Figure out how much work is left and wait that long</li>
</ul>
</li>
<li>If interrupted<ul>
<li>Save the current job as <code>pending</code> to be picked up later</li>
<li>Wait as long as the time specified in the interruption as its <code>cause</code></li>
<li>Remember to record the time worked until the interruption</li>
</ul>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="interrupt_resume.py">def programmer(sim, worker_id):
    pending = None
    while True:
        job = None
        started = None
        try:
            # Try to get job.
            if pending is None:
                job = yield sim.queue.get()
                job.t_start = sim.env.now
                job.worker_id = worker_id
            else:
                job = pending
                pending = None

            # Work on job.
            started = sim.env.now
            remaining = job.t_develop - job.t_done
            yield sim.env.timeout(remaining)
            job.t_done += remaining
            job.t_end = sim.env.now
            pending = None

        except Interrupt as exc:
            if job is not None:
                job.n_interrupt += 1
                job.t_done += sim.env.now - started
                pending = job
            yield sim.env.timeout(exc.cause)
</code></pre>
<ul>
<li>This is the most complicated process we've seen so far</li>
<li>And it contains a bug</li>
<li>Keep track of interruption times</li>
<li>And modify <code>main</code> to record exit status:</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="interrupt_resume.py">    sim = Simulation(params)
    status = "completed"
    try:
        sim.run()
    except Interrupt:
        status = f"uncaught interruption at {sim.env.now:.3f}"
    result = {
        …as before…
        "interrupts": [rv(i) for i in sim.interrupts],
        "status": status,
    }
    json.dump(result, sys.stdout, indent=2)
</code></pre>
<pre class="language-json"><code class="language-json" data-file="interrupt_resume.json">{
  "params": {
    …parameters…
  },
  "lengths": [
    …queue lengths…
  ],
  "jobs": [
    …jobs…
  ],
  "interrupts": [
    8.721,
    16.949,
    17.291
  ],
  "status": "uncaught interruption at 17.291"
}
</code></pre>
<ul>
<li>What if we're interrupted while we're handling an interruption?<ul>
<li>The <code>except</code> block only handles an <code>Interrupt</code> raised during its <code>try</code></li>
<li>We can be hit by another interruption while we're inside it</li>
</ul>
</li>
<li>We're actually lucky this happened so soon<ul>
<li>Timing bugs can lurk in code for decades</li>
</ul>
</li>
</ul>
<h2>Resuming Interrupted Work Correctly</h2>
<ul>
<li><code>programmer</code> is too complicated</li>
<li>Model interrupts as jobs</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="interrupt_resume_corrected.py">def interruptor(sim):
    while True:
        yield sim.env.timeout(sim.rand_interrupt())
        programmer = random.choice(sim.programmers)
        programmer.interrupt(Job(sim, "interrupt", sim.params["t_interrupt_len"]))
</code></pre>
<ul>
<li>Modify <code>Job</code> to keep track of kind</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="interrupt_resume_corrected.py">class Job:
    def __init__(self, sim, kind, develop):
        …as before…
        self.kind = kind
</code></pre>
<ul>
<li>Modify <code>programmer</code> to:<ol>
<li>Keep a stack of work</li>
<li>Only use <code>yield</code> inside the <code>try</code> block</li>
</ol>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="interrupt_resume_corrected.py">def programmer(sim, worker_id):
    stack = []
    while True:
        started = None
        try:
            if len(stack) == 0:
                # try to get a new regular job
            else:
                # try to finish the top job on the stack
        except Interrupt as exc:
            # save work done so far and push interruption on the stack
</code></pre>
<pre class="language-python"><code class="language-python" data-file="interrupt_resume_corrected.py">def programmer(sim, worker_id):
    stack = []
    while True:
        started = None
        try:
            if len(stack) == 0:
                # try to get a new regular job
                job = yield sim.queue.get()
                job.worker_id = worker_id
                stack.append(job)
            else:
                # try to finish the top job on the stack
        except Interrupt as exc:
            # save work done so far and push interruption on the stack
</code></pre>
<pre class="language-python"><code class="language-python" data-file="interrupt_resume_corrected.py">def programmer(sim, worker_id):
    stack = []
    while True:
        started = None
        try:
            if len(stack) == 0:
                # try to get a new regular job
            else:
                # try to finish the top job on the stack
                job = stack[-1]
                if job.t_start is None:
                    job.t_start = sim.env.now
                started = sim.env.now
                yield sim.env.timeout(job.t_develop - job.t_done)
                job.t_done = job.t_develop
                job.t_end = sim.env.now
                stack.pop()
        except Interrupt as exc:
            # save work done so far and push interruption on the stack
</code></pre>
<pre class="language-python"><code class="language-python" data-file="interrupt_resume_corrected.py">def programmer(sim, worker_id):
    stack = []
    while True:
        started = None
        try:
            if len(stack) == 0:
                # try to get a new regular job
            else:
                # try to finish the top job on the stack
        except Interrupt as exc:
            # save work done so far and push interruption on the stack
            if (len(stack) &gt; 0) and (started is not None):
                job = stack[-1]
                job.n_interrupt += 1
                job.t_done += sim.env.now - started
            stack.append(exc.cause)
</code></pre>
<ul>
<li>What happens as we increase the number of programmers?</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: right;">n_programmer</th>
<th style="text-align: right;">n_regular</th>
<th style="text-align: right;">…started</th>
<th style="text-align: right;">…completed</th>
<th style="text-align: right;">n_interrupt</th>
<th style="text-align: right;">…started</th>
<th style="text-align: right;">…completed</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1031</td>
<td style="text-align: right;">32</td>
<td style="text-align: right;">31</td>
<td style="text-align: right;">198</td>
<td style="text-align: right;">198</td>
<td style="text-align: right;">181</td>
</tr>
<tr>
<td style="text-align: right;">2</td>
<td style="text-align: right;">1031</td>
<td style="text-align: right;">527</td>
<td style="text-align: right;">525</td>
<td style="text-align: right;">198</td>
<td style="text-align: right;">198</td>
<td style="text-align: right;">195</td>
</tr>
<tr>
<td style="text-align: right;">3</td>
<td style="text-align: right;">1010</td>
<td style="text-align: right;">971</td>
<td style="text-align: right;">968</td>
<td style="text-align: right;">220</td>
<td style="text-align: right;">220</td>
<td style="text-align: right;">220</td>
</tr>
</tbody>
</table>
<ul>
<li>More regular jobs are started</li>
<li>Fraction that are completed stays the same</li>
<li>Fraction of interrupts completed stays the same</li>
<li>Now let's double the frequency of interruptions</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: right;">n_programmer</th>
<th style="text-align: right;">n_regular</th>
<th style="text-align: right;">…started</th>
<th style="text-align: right;">…completed</th>
<th style="text-align: right;">n_interrupt</th>
<th style="text-align: right;">…started</th>
<th style="text-align: right;">…completed</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: right;">1</td>
<td style="text-align: right;">1025</td>
<td style="text-align: right;">4</td>
<td style="text-align: right;">3</td>
<td style="text-align: right;">383</td>
<td style="text-align: right;">383</td>
<td style="text-align: right;">78</td>
</tr>
<tr>
<td style="text-align: right;">2</td>
<td style="text-align: right;">1025</td>
<td style="text-align: right;">84</td>
<td style="text-align: right;">82</td>
<td style="text-align: right;">383</td>
<td style="text-align: right;">383</td>
<td style="text-align: right;">355</td>
</tr>
<tr>
<td style="text-align: right;">3</td>
<td style="text-align: right;">998</td>
<td style="text-align: right;">547</td>
<td style="text-align: right;">544</td>
<td style="text-align: right;">378</td>
<td style="text-align: right;">378</td>
<td style="text-align: right;">376</td>
</tr>
</tbody>
</table>
<ul>
<li>Number of regular jobs completed is 10% with 1 programmer, 15% with 2, and 56% with 3</li>
<li>Number of self-interruptions climbs as expected</li>
</ul>
<div class="center">
<img alt="self-interruption frequency vs. job arrival rate and number of programmers" src="analyze_self_interrupt.svg"/>
</div>
<ul>
<li>Key points<ol>
<li>Everything that yields must be inside the <code>try</code> block</li>
<li>Keep state simple or you'll never debug it</li>
</ol>
</li>
</ul>
</main>
<footer>
<div class="row">
<div class="col-3 left">
	  ⇐ <a href="../features/">More Features</a>
</div>
<div class="col-6 center">
<a href="../"></a>
	  © 2025
	  <a href="../#acknowledgments">the authors</a>
</div>
<div class="col-3 right">
<a href="../finale/">Conclusion</a> ⇒
	</div>
</div>
</footer>
</body>
</html>