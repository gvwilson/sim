<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Feedback</title>
<link href="../static/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="../static/page.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav>
<a href="../">Home</a>
      ·
      <span class="dropdown">
<a href="#">Lessons</a>
<span class="dropdown-content" id="nav-lessons">
<a href="../intro/">Introduction</a>
<a href="../simple/">Simple Simulations</a>
<a href="../teams/">Teams</a>
<a href="../features/">More Features</a>
<a href="../interrupts/">Interruptions</a>
<a href="../feedback/">Feedback</a>
<a href="../finale/">Conclusion</a>
</span>
</span>
      ·
      <span class="dropdown">
<a href="#">Appendices</a>
<span class="dropdown-content" id="nav-appendices">
<a href="../generators/">Generators</a>
<a href="../license/">License</a>
<a href="../conduct/">Code of Conduct</a>
<a href="../contributing/">Contributing</a>
<a href="../bibliography/">Bibliography</a>
<a href="../glossary/">Glossary</a>
</span>
</span>
</nav>
<main>
<h1>Feedback</h1>
<ul>
<li>Because programmers don't always get it right the first time</li>
</ul>
<h2>Adding Testers</h2>
<ul>
<li>Parameter sweeping once again</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="simple_testing.py">PARAMS = {
    "n_programmer": (2, 3, 4),
    "n_tester": (2, 3, 4),
    "p_rework": (0.2, 0.4, 0.6, 0.8),
    …as before…
}

def main():
    random.seed(PARAMS["seed"])
    result = []
    combinations = product(PARAMS["n_programmer"], PARAMS["n_tester"], PARAMS["p_rework"])
    for (n_programmer, n_tester, p_rework) in combinations:
        sweep = {"n_programmer": n_programmer, "n_tester": n_tester, "p_rework": p_rework}
        params = {**PARAMS, **sweep}
        sim = Simulation(params)
        sim.run()
        result.append({
            "params": params,
            "lengths": sim.lengths,
            "jobs": [job.as_json() for job in Job._all],
        })
    json.dump(result, sys.stdout, indent=2)
</code></pre>
<ul>
<li>Two queues</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="simple_testing.py">class Simulation:
    def __init__(self, params):
        self.params = params
        self.env = Environment()
        self.prog_queue = Store(self.env)
        self.test_queue = Store(self.env)
        self.lengths = []
</code></pre>
<ul>
<li>Programmers get from one queue and add to another</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="simple_testing.py">def programmer(sim, worker_id):
    while True:
        job = yield sim.prog_queue.get()
        start = sim.env.now
        yield sim.env.timeout(sim.rand_dev())
        job.n_prog += 1
        job.t_prog += sim.env.now - start
        yield sim.test_queue.put(job)
</code></pre>
<ul>
<li>Testers get from the second queue and either recirculate the job or mark it as done</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="simple_testing.py">def tester(sim, tester_id):
    while True:
        job = yield sim.test_queue.get()
        start = sim.env.now
        yield sim.env.timeout(sim.rand_dev())
        job.n_test += 1
        job.t_test += sim.env.now - start
        if sim.rand_rework():
            yield sim.prog_queue.put(job)
        else:
            job.done = True
</code></pre>
<ul>
<li>Queue lengths</li>
</ul>
<div class="center">
<img alt="queue lengths" src="analyze_simple_testing_queues_1000.svg"/>
</div>
<ul>
<li>Times for jobs that were started</li>
</ul>
<p>
<img alt="Programming and testing times" src="analyze_simple_testing_times_1000.svg"/>
</p>
<ul>
<li>Gosh, this is hard to understand…</li>
</ul>
<h2>Using Classes</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Simula">Simula</a>: object-oriented programming was invented to support simulation</li>
<li>Before making our simulation more realistic, <a href="../glossary/#refactor">refactor</a> to use classes</li>
<li><code>Simulation</code> creates objects for programmers and testers<ul>
<li>Their classes are responsible for creating and running generators</li>
</ul>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="class_testing.py">class Simulation:
    …all other code as before…
    def run(self):
        Job.clear()
        self.env.process(self.monitor())
        self.env.process(creator(self))
        self.programmers = [Programmer(self, i) for i in range(self.params["n_programmer"])]
        self.testers = [Tester(self, i) for i in range(self.params["n_tester"])]
        self.env.run(until=self.params["t_sim"])
</code></pre>
<ul>
<li>Generic <code>Worker</code> stores a reference to the simulation and its ID</li>
<li>Then calls a <code>.run</code> method and saves a reference to the generator<ul>
<li>In case we want to interrupt it</li>
</ul>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="class_testing.py">class Worker:
    def __init__(self, sim, id):
        self.sim = sim
        self.id = id
        self.proc = sim.env.process(self.run())
</code></pre>
<ul>
<li><code>Programmer</code> implements <code>.run</code><ul>
<li>Identical to previous naked generator except <code>sim</code> becomes <code>self.sim</code></li>
</ul>
</li>
<li>Similar change to <code>Tester</code> (not shown here)</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="class_testing.py">class Programmer(Worker):
    def run(self):
        while True:
            job = yield self.sim.prog_queue.get()
            job.programmer_id = self.id
            start = self.sim.env.now
            yield self.sim.env.timeout(self.sim.rand_dev())
            job.n_prog += 1
            job.t_prog += self.sim.env.now - start
            yield self.sim.test_queue.put(job)
</code></pre>
<ul>
<li>We haven't changed the order of operations…</li>
<li>…so the random number generator should produce the same values at the same moments…</li>
<li>…so we can test our changes by checking that the output of the refactored version
    is identical to the output of the original version</li>
</ul>
<h2>Exploring Scenarios</h2>
<ul>
<li>Option 1: everything that needs re-work goes back in the shared queues<ul>
<li>Which means any programmer and tester can pick it up</li>
<li>Which isn't realistic</li>
</ul>
</li>
<li>Option 2: work goes back to the same programmer and tester who handled it the first time<ul>
<li>Which requires some changes to our simulation</li>
</ul>
</li>
<li>Option 3: same as 2, but it takes less time for people to re-do work<ul>
<li>Which is realistic…</li>
<li>…except we have to guess at the discount ratio</li>
</ul>
</li>
<li>Modify <code>Worker</code> constructor to give each worker (programmer or tester) their own queue</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="scenario_testing.py">class Worker:
    def __init__(self, sim, id):
        self.sim = sim
        self.id = id
        self.queue = Store(sim.env)
        self.proc = sim.env.process(self.run())
</code></pre>
<ul>
<li>Modify <code>Programmer</code> to:<ul>
<li>Keep track of which of the shared queues it gets jobs from</li>
<li>Call a method <code>self.choose()</code> to get a job (we'll write this in a moment)</li>
<li>Put the completed job in either the all-purpose testing queue (if it hasn't been tested before)
    or the queue belonging to a specific tester (if it has)</li>
</ul>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="scenario_testing.py">class Programmer(Worker):
    def __init__(self, sim, id):
        super().__init__(sim, id)
        self.shared_queue = self.sim.prog_queue  # added

    def run(self):
        while True:
            job = yield from self.choose()  # changed
            job.programmer_id = self.id
            start = self.sim.env.now
            yield self.sim.env.timeout(self.factor() * self.sim.rand_dev())
            job.n_prog += 1
            job.t_prog += self.sim.env.now - start

            # hand off the job
            if job.tester_id is None:
                yield self.sim.test_queue.put(job)
            else:
                yield self.sim.testers[job.tester_id].queue.put(job)
</code></pre>
<ul>
<li>Similar change to <code>Tester</code></li>
<li>Now, how does <code>self.choose()</code> work?<ul>
<li>Put it in the generic <code>Worker</code> class because both <code>Programmer</code> and <code>Tester</code> need it</li>
<li>This is why we recorded the shared queue in the constructors for <code>Programmer</code> and <code>Tester</code></li>
</ul>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="scenario_testing.py">class Worker:
    def choose(self):
        if self.sim.params["scenario"] == "any":
            job = yield self.shared_queue.get()
        elif self.sim.params["scenario"] in ("same", "reduced"):
            job = yield from self.choose_same()
        else:
            assert False, f"unknown scenario {self.sim.params['scenario']}"
        return job
</code></pre>
<ul>
<li>The hard work is in the <code>.choose_same</code> method<ul>
<li>Create <em>but do not immediately <code>yield</code></em> a request for an item from each queue</li>
<li><code>yield</code> the combination of those items using <code>|</code> (a short form for <code>simpy.AnyOf</code>)</li>
<li><code>result</code> is dictionary-like object whose keys are the requests
    and whose values are the items that we got</li>
<li>If we got something from our own queue, take that</li>
<li>If not, take what we got from the shared queue</li>
<li>Important: we have to cancel the other request or we can't make another one from that queue</li>
<li>Yes, this took me a while to figure out</li>
<li>And yes, it's safe to cancel a request that wasn't satisfied</li>
</ul>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="scenario_testing.py">    def choose_same(self):
        req_shared = self.shared_queue.get()
        req_own = self.queue.get()
        result = yield (req_shared | req_own)
        if (len(result.events) == 2) or (req_own in result):
            job = result[req_own]
            req_shared.cancel()
        else:
            job = result[req_shared]
            req_own.cancel()
        return job
</code></pre>
<ul>
<li>So what are the results?</li>
</ul>
<div class="center">
<img alt="three testing scenarios" src="analyze_scenario_testing.svg"/>
</div>
<ul>
<li>If anyone can do the rework, we wind up with a lot of jobs stuck in progress,
    but very very that haven't even been started</li>
<li>If work goes back to the same people <em>and</em> it takes them half as long to re-do jobs,
    we complete a lot more work <em>and</em> we have less of a backlog</li>
<li>The one I didn't predict: if work goes back to the same people but there is no time saving,
    we still complete a lot more jobs<ul>
<li>Because we're giving re-work priority over new work</li>
<li>The backlog grows more quickly than in the "anyone can do it"scenario,
    but the number of incomplete jobs grows more slowly</li>
</ul>
</li>
<li>This is why we simulate…</li>
</ul>
</main>
<footer>
<div class="row">
<div class="col-3 left">
	  ⇐ <a href="../interrupts/">Interruptions</a>
</div>
<div class="col-6 center">
<a href="../"></a>
	  © 2025
	  <a href="../#acknowledgments">the authors</a>
</div>
<div class="col-3 right">
<a href="../finale/">Conclusion</a> ⇒
	</div>
</div>
</footer>
</body>
</html>