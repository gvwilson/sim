<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Teams</title>
<link href="../static/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="../static/page.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav>
<a href="../">Home</a>
      ·
      <span class="dropdown">
<a href="#">Lessons</a>
<span class="dropdown-content" id="nav-lessons">
<a href="../intro/">Introduction</a>
<a href="../simple/">Simple Simulations</a>
<a href="../teams/">Teams</a>
<a href="../features/">More Features</a>
<a href="../finale/">Conclusion</a>
</span>
</span>
      ·
      <span class="dropdown">
<a href="#">Appendices</a>
<span class="dropdown-content" id="nav-appendices">
<a href="../generators/">Generators</a>
<a href="../license/">License</a>
<a href="../conduct/">Code of Conduct</a>
<a href="../contributing/">Contributing</a>
<a href="../bibliography/">Bibliography</a>
<a href="../glossary/">Glossary</a>
</span>
</span>
</nav>
<main>
<h1>Teams</h1>
<ul>
<li>Assume probability of manager generating a new job in any instant is fixed<ul>
<li>I.e., doesn't depend on how long since the last job was generated</li>
</ul>
</li>
<li>If the arrival rate (jobs per tick) is λ,
    the time until the next job is an <a href="../glossary/#random-exponential">exponential</a> random variable
    with mean 1/λ</li>
</ul>
<div class="center">
<img alt="exponential distribution" src="plot_exponential.svg"/>
</div>
<ul>
<li>Use a <a href="../glossary/#random-log-normal">log-normal</a> random variable to model job lengths<ul>
<li>Most jobs are short but there are a few outliers</li>
<li>If parameters are μ and σ, <a href="../glossary/#median">median</a> is e<sup>μ</sup></li>
</ul>
</li>
</ul>
<div class="center">
<img alt="log-normal distribution" src="plot_log_normal.svg"/>
</div>
<h2>One Manager with Multiple Programmers</h2>
<ul>
<li>Store all our parameters in a dictionary</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="multiple_programmers.py">PARAMS = {
    "n_programmer": 3,
    "seed": 12345,
    "t_develop_mu": 0.5,
    "t_develop_sigma": 0.6,
    "t_job_arrival": 1.0,
    "t_sim": 10,
}
</code></pre>
<ul>
<li>Create a <code>Simulation</code> class to hold all our odds and ends</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="multiple_programmers.py">class Simulation:
    def __init__(self, params):
        self.params = params
        self.env = Environment()
        self.queue = Store(self.env)

    def rand_job_arrival(self):
        return random.expovariate(1.0 / self.params["t_job_arrival"])

    def rand_develop(self):
        return random.lognormvariate(
            self.params["t_develop_mu"], self.params["t_develop_sigma"]
        )
</code></pre>
<ul>
<li>Create a <code>Job</code> class to store details of jobs<ul>
<li>And teach it how to convert itself to a dictionary for JSON output</li>
<li>Don't save <code>t_develop</code> because that would be cheating</li>
</ul>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="multiple_programmers.py">class Job:
    SAVE = ("id", "t_create", "t_start", "t_end", "worker_id")
    _id = count()
    _all = []

    def __init__(self, sim):
        Job._all.append(self)
        self.sim = sim
        self.id = next(Job._id)
        self.t_develop = sim.rand_develop()
        self.t_create = sim.env.now
        self.t_start = None
        self.t_end = None
        self.worker_id = None

    def as_json(self):
        return {key: rv(getattr(self, key)) for key in Job.SAVE}
</code></pre>
<ul>
<li><code>Manager</code> creates jobs at random intervals</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="multiple_programmers.py">def manager(sim):
    while True:
        yield sim.queue.put(Job(sim))
        yield sim.env.timeout(sim.rand_job_arrival())
</code></pre>
<ul>
<li><code>Programmer</code> does jobs and bookkeeping</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="multiple_programmers.py">def programmer(sim, worker_id):
    while True:
        job = yield sim.queue.get()
        job.t_start = sim.env.now
        job.worker_id = worker_id
        yield sim.env.timeout(job.t_develop)
        job.t_end = sim.env.now
</code></pre>
<ul>
<li>Main driver sets things up, runs the simulation, and saves the parameters and job details</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="multiple_programmers.py">def main():
    params = get_params()
    random.seed(params["seed"])

    sim = Simulation(params)

    sim.env.process(manager(sim))
    for i in range(params["n_programmer"]):
        sim.env.process(programmer(sim, i))
    sim.env.run(until=params["t_sim"])

    result = {
        "params": params,
        "jobs": [job.as_json() for job in Job._all],
    }
    json.dump(result, sys.stdout, indent=2)
</code></pre>
<ul>
<li>Output</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="multiple_programmers.json">{
  "params": {
    "n_programmer": 3,
    "seed": 12345,
    "t_develop_mu": 0.4,
    "t_develop_sigma": 0.5,
    "t_job_arrival": 1.0,
    "t_sim": 10
  },
  "jobs": [
    {
      "id": 0,
      "t_create": 0,
      "t_start": 0,
      "t_end": 1.388,
      "worker_id": 0
    },
    …other jobs…
    {
      "id": 9,
      "t_create": 9.995,
      "t_start": 9.995,
      "t_end": null,
      "worker_id": 1
    }
  ]
}
</code></pre>
<ul>
<li>Analysis after 5000 ticks</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">result</th>
<th style="text-align: right;">value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">mean inter-job arrival time</td>
<td style="text-align: right;">0.983</td>
</tr>
<tr>
<td style="text-align: left;">mean job execution time</td>
<td style="text-align: right;">1.973</td>
</tr>
<tr>
<td style="text-align: left;">utilization</td>
<td style="text-align: right;">0.668</td>
</tr>
</tbody>
</table>
<ul>
<li>Job arrival time is pretty close to 1.0</li>
<li>Job execution time is right on <code>exp(mu + (sigma ** 2 / 2))</code></li>
<li>Utilization is close to job time divided by number of programmers</li>
<li>Queue is essentially empty<ul>
<li>Manager isn't creating enough work to keep programmers busy</li>
</ul>
</li>
</ul>
<h2>Watch the Backlog Grow</h2>
<ul>
<li>Once Shae's manager realizes the programmers aren't busy 100% of the time,
    she starts giving them more work</li>
<li>Use <a href="../glossary/#parameter-sweeping">parameter sweeping</a> to Look at effect on <a href="../glossary/#backlog">backlog</a></li>
<li>Move code to run simulation into <code>Simulation</code> class</li>
<li>Add a monitoring process that records the queue length every <em>N</em> ticks<ul>
<li>Observation rather than instrumentation</li>
<li>Clear the log of all jobs each time the simulation starts</li>
</ul>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="queue_lengths.py">class Simulation:
    def __init__(self, params):
        …as before…
        self.queue_lengths = []

    def run(self):
        Job.clear()
        self.env.process(self.monitor())
        self.env.process(manager(self))
        for i in range(self.params["n_programmer"]):
            self.env.process(programmer(self, i))
        self.env.run(until=self.params["t_sim"])

    def monitor(self):
        while True:
            self.queue_lengths.append({"time": rv(self.env.now), "length": len(self.queue.items)})
            yield self.env.timeout(self.params["t_monitor"])
</code></pre>
<ul>
<li>Look at queue length over time as a function of arrival times<ul>
<li>Shorter arrival times = jobs arriving more frequently</li>
</ul>
</li>
</ul>
<div class="center">
<img alt="queue length as a function of job arrival times" src="analyze_queue_lengths.svg"/>
</div>
<ul>
<li>The faster jobs arrive, the larger the spikes in backlog</li>
<li>But the programmers always seem to be able to clear the backlog…</li>
<li>…until jobs are spaced out by about 0.6 ticks</li>
<li>Do some math<ul>
<li>Mean job execution time: 1.973 ticks</li>
<li>Number of programmers: 3</li>
<li>Jobs executed per tick: 3 / 1.973 = 1.52</li>
<li>So programmers should be able to handle jobs arriving at a rate of 1 / 1.52 = 0.65 ticks</li>
</ul>
</li>
</ul>
<div class="center">
<img alt="zoom in on queue length" src="analyze_queue_lengths_zoom.svg"/>
</div>
<ul>
<li>Everything is fine until suddenly it's not</li>
</ul>
<h2>A Little Bit of Theory</h2>
<ul>
<li>λ (lambda) is the arrival rate (the average number of jobs arriving per unit time)</li>
<li>L is the average number of customers in the system</li>
<li>W is average time a customer spends in the system</li>
<li>
<p><a href="../glossary/#littles-law">Little's Law</a>: L = λW</p>
</li>
<li>
<p>μ (mu) is the service rate (the average number of jobs a single server can serve per unit time)</p>
</li>
<li>ρ (rho) is the utilization (the fraction of time the server is busy)</li>
<li>
<p>ρ = λ / μ for single-server systems <em>if λ &lt; μ</em></p>
<ul>
<li>If λ ≥ μ, the queue grows without limit</li>
</ul>
</li>
<li>
<p>Average waiting time in queue W<sub>q</sub> = ρ / (μ (1 - ρ))</p>
<ul>
<li>Think of (1 - ρ) as spare capacity</li>
<li>As the system approaches saturation, waiting times increase rapidly</li>
</ul>
</li>
<li>
<p>If all your programmers are busy 100% of the time,
    the waiting time for new work explodes</p>
</li>
<li>You must have slack in the system in order to keep waiting times down</li>
</ul>
</main>
<footer>
<div class="row">
<div class="col-3 left">
	  ⇐ <a href="../simple/">Simple Simulations</a>
</div>
<div class="col-6 center">
<a href="../"></a>
	  © 2025
	  <a href="../#acknowledgments">the authors</a>
</div>
<div class="col-3 right">
<a href="../features/">More Features</a> ⇒
	</div>
</div>
</footer>
</body>
</html>